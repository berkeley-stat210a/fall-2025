<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Testing with One Real Parameter</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7b1b06e26e1e2798ccde3208f86b5bbd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-B8G2041HSB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-B8G2041HSB', { 'anonymize_ip': true});
</script>
<script async="" src="https://siteimproveanalytics.com/js/siteanalyze_6294756.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../assets/styles.css">
</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#testing-with-one-real-parameter" id="toc-testing-with-one-real-parameter" class="nav-link active" data-scroll-target="#testing-with-one-real-parameter"><span class="header-section-number">1</span> Testing with one real parameter</a></li>
  <li><a href="#one-sided-testing" id="toc-one-sided-testing" class="nav-link" data-scroll-target="#one-sided-testing"><span class="header-section-number">2</span> One-sided testing</a>
  <ul class="collapse">
  <li><a href="#score-test" id="toc-score-test" class="nav-link" data-scroll-target="#score-test"><span class="header-section-number">2.1</span> Score test</a></li>
  <li><a href="#the-sign-test-as-a-nonparametric-test" id="toc-the-sign-test-as-a-nonparametric-test" class="nav-link" data-scroll-target="#the-sign-test-as-a-nonparametric-test"><span class="header-section-number">2.2</span> The sign test as a nonparametric test</a></li>
  </ul></li>
  <li><a href="#two-sided-alternatives" id="toc-two-sided-alternatives" class="nav-link" data-scroll-target="#two-sided-alternatives"><span class="header-section-number">3</span> Two-sided alternatives</a>
  <ul class="collapse">
  <li><a href="#two-tailed-tests" id="toc-two-tailed-tests" class="nav-link" data-scroll-target="#two-tailed-tests"><span class="header-section-number">3.1</span> Two-tailed tests</a></li>
  <li><a href="#exponential-example" id="toc-exponential-example" class="nav-link" data-scroll-target="#exponential-example"><span class="header-section-number">3.2</span> Exponential example</a></li>
  <li><a href="#optimal-unbiased-tests" id="toc-optimal-unbiased-tests" class="nav-link" data-scroll-target="#optimal-unbiased-tests"><span class="header-section-number">3.3</span> Optimal unbiased tests</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Testing with One Real Parameter</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><span class="math display">\[
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\td}{\,\textrm{d}}
\newcommand{\simiid}{\stackrel{\textrm{i.i.d.}}{\sim}}
\newcommand{\simind}{\stackrel{\textrm{ind.}}{\sim}}
\newcommand{\eqas}{\stackrel{\textrm{a.s.}}{=}}
\newcommand{\eqPas}{\stackrel{\cP\textrm{-a.s.}}{=}}
\newcommand{\eqmuas}{\stackrel{\mu\textrm{-a.s.}}{=}}
\newcommand{\eqD}{\stackrel{D}{=}}
\newcommand{\indep}{\perp\!\!\!\!\perp}
\DeclareMathOperator*{\minz}{minimize\;}
\DeclareMathOperator*{\maxz}{minimize\;}
\DeclareMathOperator*{\argmin}{argmin\;}
\DeclareMathOperator*{\argmax}{argmax\;}
\newcommand{\Var}{\textnormal{Var}}
\newcommand{\Cov}{\textnormal{Cov}}
\newcommand{\Corr}{\textnormal{Corr}}
\]</span></p>
<section id="testing-with-one-real-parameter" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="testing-with-one-real-parameter"><span class="header-section-number">1</span> Testing with one real parameter</h2>
<p>This lecture concerns the general problem of testing with one real parameter. We observe <span class="math inline">\(X \sim P_\theta\)</span> for <span class="math inline">\(\theta \in \Theta \subseteq \RR\)</span>, and we might want to test a <em>one-sided alternative</em> like <span class="math inline">\(H_0:\; \theta \leq \theta_0\)</span> vs the one-sided alternative <span class="math inline">\(H_1:\; \theta &gt; \theta_0\)</span>, or a <em>point null</em> hypothesis like <span class="math inline">\(H_0:\; \theta = \theta_0\)</span> against a <em>two-sided alternative</em> <span class="math inline">\(H_1:\; \theta \neq \theta_0\)</span>. Or, we could test an <em>interval null</em> <span class="math inline">\(H_0:\; |\theta - \theta_0| \leq \delta\)</span> vs the two-sided alternative <span class="math inline">\(H_1:\; |\theta-\theta_0|&gt;\delta\)</span>, for <span class="math inline">\(\delta \geq 0\)</span> (which reduces to the point null if <span class="math inline">\(\delta = 0\)</span>).</p>
</section>
<section id="one-sided-testing" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="one-sided-testing"><span class="header-section-number">2</span> One-sided testing</h2>
<p>Last time, we showed that if the family <span class="math inline">\(\cP\)</span> has MLR in the statistic <span class="math inline">\(T(X)\)</span>, then the one-sided test that rejects for large <span class="math inline">\(T(X)\)</span> is UMP for testing <span class="math inline">\(H_0:\;\theta\leq \theta_0\)</span> vs <span class="math inline">\(H_1:\;\theta &gt; \theta_0\)</span>, because:</p>
<ol type="i">
<li><p>it is simultaneously the likelihood ratio test for <span class="math inline">\(H_0:\;\theta = \theta_0\)</span> vs <span class="math inline">\(H_1:\;\theta = \theta_1\)</span>, for every <span class="math inline">\(\theta_1 &gt; 0\)</span>, and</p></li>
<li><p>it controls the Type I error for all <span class="math inline">\(\theta &lt; \theta_0\)</span>.</p></li>
</ol>
<p>Recall that a test <em>rejects for large <span class="math inline">\(T(X)\)</span></em> if it is of the form <span class="math display">\[\phi(X) = \begin{cases} 1 &amp;\quad \text{ if } T(X) &gt; c \\ 0 &amp;\quad \text{ if } T(X) &lt; c\\ \gamma &amp;\quad \text{ if } T(X) = c\end{cases},\]</span> where the critical threshold <span class="math inline">\(c\)</span> is the <em>upper-<span class="math inline">\(\alpha\)</span> quantile at the boundary</em> <span class="math display">\[
c_\alpha = \min \{c \in \RR:\; \PP_{\theta_0}(T(X) &gt; c) \leq \alpha\}
\]</span> and the randomization parameter <span class="math inline">\(\gamma\)</span> is used to “top off” the Type I error rate if <span class="math inline">\(T(X)\)</span> is discrete and <span class="math inline">\(\PP_{\theta_0}(T(X) &gt; c_\alpha) &lt; \alpha\)</span>. In the rest of this section we will ignore randomization and assume that we just accept a conservative test in case <span class="math inline">\(\PP_{\theta_0}(T(X) &gt; c_\alpha) &lt; \alpha\)</span> (as is generally done in practice).</p>
<p>A generic one-parameter model <span class="math inline">\(\cP\)</span> does not have MLR in any statistic <span class="math inline">\(T(X)\)</span>; e.g.&nbsp;the LRT for testing <span class="math inline">\(\theta_0\)</span> vs <span class="math inline">\(\theta_1=\theta_0 + 1\)</span> does not coincide with the LRT for testing <span class="math inline">\(\theta_0\)</span> vs <span class="math inline">\(\theta_1=\theta_0 +  2\)</span>. Then we cannot maximize power for both alternative values <span class="math inline">\(\theta_0+1\)</span> and <span class="math inline">\(\theta_0+2\)</span> simultaneously.</p>
<p>In such cases, we could still come up with a test that rejects for large values of some other test statistic <span class="math inline">\(T(X)\)</span>, that tends to be larger when <span class="math inline">\(\theta\)</span> is larger. Formally, we say that <span class="math inline">\(T(X)\)</span> is <em>stochastically increasing in <span class="math inline">\(\theta\)</span></em> if <span class="math inline">\(\PP_\theta(T(X) &gt; c)\)</span> is non-decreasing in <span class="math inline">\(\theta\)</span>, for every <span class="math inline">\(c \in \RR\)</span>. The power function of <span class="math inline">\(\phi(X) = 1\{T(X) &gt; c_\alpha\}\)</span>, then, is also non-decreasing in <span class="math inline">\(\theta\)</span>, and <span class="math inline">\(\phi(X)\)</span> is a valid test of <span class="math inline">\(H_0:\;\theta\leq \theta_0\)</span> vs <span class="math inline">\(H_1:\;\theta &gt; \theta_0\)</span>.</p>
<section id="score-test" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="score-test"><span class="header-section-number">2.1</span> Score test</h3>
<p>Suppose we observe <span class="math inline">\(X_1,\ldots,X_n \simiid P_\theta\)</span> for large <span class="math inline">\(n\)</span>, and we want to test <span class="math inline">\(H_0:\;\theta\leq \theta_0\)</span> vs <span class="math inline">\(H_1:\;\theta &gt; \theta_0\)</span>, but <span class="math inline">\(\cP\)</span> does not have MLR so we cannot maximize the power over the entirety of <span class="math inline">\(H_1\)</span>. One idea is to use the heuristic of maximizing the power for alternatives near <span class="math inline">\(\theta_0\)</span>; if <span class="math inline">\(n\)</span> is large, then we have a lot of information about <span class="math inline">\(\theta\)</span> so our power will be close to <span class="math inline">\(1\)</span> no matter what we do. So we might prioritize maximizing the power at <span class="math inline">\(\theta_0 + \varepsilon\)</span> for small <span class="math inline">\(\varepsilon\)</span>.</p>
<p>The LRT for <span class="math inline">\(\theta_0\)</span> vs <span class="math inline">\(\theta_0 + \varepsilon\)</span> rejects for large values of <span class="math display">\[ \frac{p_{\theta_0+\varepsilon}(X)}{p_{\theta_0}(X)} =\exp\{\ell(\theta_0+\varepsilon; X) - \ell(\theta_0; X)\} \approx e^{\varepsilon \dot\ell(\theta_0;X)},\]</span> which is equivalent to rejecting for large values of <span class="math inline">\(\dot\ell(\theta_0;X)\)</span>. Using the score statistic can give simple and appealing tests in certain situations.</p>
<p><strong>Example: Laplace</strong></p>
<p>Suppose <span class="math inline">\(X_1,\ldots,X_n \simiid \text{Laplace}(\theta) = \frac{1}{2}e^{-|x-\theta|}\)</span> and we want to test <span class="math inline">\(H_0:\theta \leq 0\)</span> vs <span class="math inline">\(H_1:\;\theta &gt; 0\)</span>. We can calculate the likelihood ratio test for a given fixed alternative <span class="math inline">\(\theta_1 &gt; 0\)</span> as</p>
<p><span class="math display">\[
\log \frac{p_{\theta_1}(X)}{p_0(X)} = \sum_i |X_i| - |X_i-\theta_1| = \theta_1\sum_i T_{\theta_1}(X_i),
\]</span> so the optimal test rejects for large <span class="math inline">\(\sum_i T_{\theta_1}(X_i)\)</span>, where <span class="math display">\[
T_{\theta}(x) = \begin{cases} -1 &amp; \text{ if } x \leq 0 \\ \frac{2x}{\theta} -1 &amp; \text{ if } 0 \leq x \leq \theta \\ +1 &amp;\text{ if } x \geq \theta \end{cases}.
\]</span> We can visualize the univariate version of the test statistic <span class="math inline">\(T_{\theta}(x)\)</span> for several different values of <span class="math inline">\(\theta&gt;0\)</span>:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="testing-one-parameter_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Note that this test implicitly caps the influence of any single observation <span class="math inline">\(X_i\)</span>. Once <span class="math inline">\(X_i &gt; \theta_1\)</span>, it gives the same evidence in favor of <span class="math inline">\(\theta_1\)</span> and against <span class="math inline">\(\theta_0\)</span> regardless of how much it exceeds <span class="math inline">\(\theta_1\)</span>. Compare this with the sample mean, where the influence of a single observation <span class="math inline">\(X_i\)</span> is unbounded. It is easy to see that <span class="math inline">\(f(X_i)\)</span> is stochastically increasing in <span class="math inline">\(\theta\)</span> for <em>any</em> non-decreasing function <span class="math inline">\(f\)</span>, so any LRT gives a valid level-<span class="math inline">\(\alpha\)</span> test on the entire null distribution.</p>
<p>If we take <span class="math inline">\(\theta_1\downarrow 0\)</span>, the univariate test statistic approaches <span class="math display">\[
T_0(x) = \begin{cases} -1 &amp; \text{ if } x \leq 0\\ +1 &amp;\text{ if } x &gt; 0\end{cases},
\]</span> which gives the score test since <span class="math display">\[
\dot{\ell}(\theta;X) = \frac{d}{d\theta} \sum_i -|X_i-\theta| = \sum_i T_0(X_i)
\]</span> This is equivalent to rejecting for large values of <span class="math inline">\(S(X) = \#\{X_i &gt; 0\}\)</span>, simply the number of positive <span class="math inline">\(X_i\)</span> values.</p>
<p>We can also plot the power curves for <span class="math inline">\(n = 100\)</span> and <span class="math inline">\(\alpha = 0.1\)</span>, for these tests and for the test that rejects for large values of <span class="math inline">\(\sum_i X_i\)</span>. As we see, the score test performs noticeably better than the test that rejects for large values of the sample mean <span class="math inline">\(\overline{X}\)</span>. But the LRT for <span class="math inline">\(\theta_1 = 0.2\)</span> seems to do best for this value of <span class="math inline">\(n\)</span>, since <span class="math inline">\(\theta_1 = 0.2\)</span> is a moderately hard alternative value for which the power is intermediate.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="testing-one-parameter_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="the-sign-test-as-a-nonparametric-test" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="the-sign-test-as-a-nonparametric-test"><span class="header-section-number">2.2</span> The sign test as a nonparametric test</h3>
<p>The test based on the statistic <span class="math inline">\(S(X) = \#\{X_i &gt; 0\}\)</span> is called the <em>sign test</em>, and is generally an appealing test for a <em>nonparametric</em> testing problem. Suppose <span class="math inline">\(X_1,\ldots,X_n \simiid F\)</span>, where <span class="math inline">\(F\)</span> represents an unknown cdf for their distribution. Assume for simplicity that <span class="math inline">\(F\)</span> is continuous and strictly increasing on its support, so that the median <span class="math inline">\(\theta(F) = F^{-1}(1/2)\)</span> is well-defined, and consider testing <span class="math inline">\(H_0:\; \theta(F) \leq 0\)</span> vs <span class="math inline">\(H_1:\; \theta(F) &gt; 0\)</span>.</p>
<p>Then <span class="math inline">\(S(X) \sim \text{Binom}(n, 1-F(0))\)</span>, where the probability parameter <span class="math inline">\(1-F(0)\)</span> is no more than <span class="math inline">\(1/2\)</span> if <span class="math inline">\(H_0\)</span> is true, but strictly greater than <span class="math inline">\(1/2\)</span> if <span class="math inline">\(H_1\)</span> is true. Then the test that rejects when <span class="math inline">\(S(X)\)</span> is above the upper <span class="math inline">\(1-\alpha\)</span> quantile of the <span class="math inline">\(\text{Binom}(n,1/2)\)</span> distribution (randomizing at the boundary if desired) is level-<span class="math inline">\(\alpha\)</span> on <span class="math inline">\(H_0\)</span>.</p>
</section>
</section>
<section id="two-sided-alternatives" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="two-sided-alternatives"><span class="header-section-number">3</span> Two-sided alternatives</h2>
<p>Often we want to test a null hypothesis against the alternative that the parameter is larger <em>or</em> smaller than a null value, or range of values. This section will consider a null hypothesis of the form <span class="math inline">\(H_0:\; |\theta - \theta_0| \leq \delta\)</span> against the alternative <span class="math inline">\(H_1:\; |\theta - \theta_0| &gt; \delta\)</span>, for some tolerance <span class="math inline">\(\delta \geq 0\)</span>. In the important special case <span class="math inline">\(\delta = 0\)</span> we will call <span class="math inline">\(H_0\)</span> a <em>point null</em>, and if <span class="math inline">\(\delta &gt; 0\)</span> we will call <span class="math inline">\(H_0\)</span> an <em>interval null</em>.</p>
<section id="two-tailed-tests" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="two-tailed-tests"><span class="header-section-number">3.1</span> Two-tailed tests</h3>
<p>To test a two-sided alternative, we will generally employ a <em>two-tailed test</em> based on some test statistic <span class="math inline">\(T(X)\)</span>. We will say that <span class="math inline">\(\phi(X)\)</span> <em>rejects for extreme <span class="math inline">\(T(X)\)</span></em> (i.e., for large or small values of <span class="math inline">\(T(X)\)</span>) if <span class="math display">\[
\phi(X) = \begin{cases} 1 &amp; \quad \text{ if } T(X) &lt; c_1 \text{ or } T(X) &gt; c_2\\
0 &amp; \quad \text{ if } c_1 &lt; T(X) &lt; c_2\\
\gamma_i &amp;\quad \text{ if } T(X) = c_i, \; i = 1,2
\end{cases}
\]</span></p>
<p>When we test with a two-sided alternative we will generally not be able to optimize power everywhere. For example, if we test <span class="math inline">\(H_0:\; \theta = 0\)</span> vs <span class="math inline">\(H_1:\; \theta \neq 0\)</span> in the <span class="math inline">\(z\)</span>-test problem <span class="math inline">\(X \sim N(\theta,1)\)</span>, we can choose any test of the form <span class="math display">\[
\phi_{\alpha_1}(x) = 1\{x &lt; -z_{\alpha_1}\} + 1\{x &gt; z_{\alpha - \alpha_1}\},
\]</span> for any <span class="math inline">\(\alpha_1 \in [0,\alpha]\)</span>. We obtain the right- and left-tailed tests in the limit where <span class="math inline">\(\alpha\)</span> is <span class="math inline">\(0\)</span> or <span class="math inline">\(\alpha\)</span> respectively, and the usual symmetric two-tailed test when <span class="math inline">\(\alpha_1 = \alpha/2\)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="testing-one-parameter_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Note that two of the three tests shown above have the undesirable property that the power falls below <span class="math inline">\(\alpha\)</span> on part of the alternative: that is, there are alternative values of <span class="math inline">\(\theta\)</span> for which our chance of rejecting the null is even less than it would be if the null were true.</p>
<p>None of the tests plotted above is as powerful for <span class="math inline">\(\theta &gt; 0\)</span> as the right-tailed test (<span class="math inline">\(\alpha_1 = 0\)</span>), and none is as powerful for <span class="math inline">\(\theta &lt; 0\)</span> as the left-tailed test (<span class="math inline">\(\alpha_1 = \alpha\)</span>), and intuitively it is clear that we cannot hope to find a test that maximizes power on both parts of the alternative.</p>
<p>As in the case with estimation, one way that we can proceed when there is no UMP test is to impose a constraint that rules out all but one test. In the <span class="math inline">\(z\)</span>-test above, the test with <span class="math inline">\(\alpha_1 = \alpha/2\)</span> is symmetric in two respects:</p>
<ol type="1">
<li><p>It is <em>equal-tailed</em>, meaning that we have dedicated an equal portion of our total Type I error budget to the left and right lobes of the rejection region, and</p></li>
<li><p>It is <em>unbiased</em>, meaning that the power is at least <span class="math inline">\(\alpha\)</span> everywhere on the alternative.</p></li>
</ol>
<p>The idea of an equal-tailed test makes sense when <span class="math inline">\(H_0\)</span> is simple, but it is not obvious how it extends to the more common situation where <span class="math inline">\(H_0\)</span> is composite. We will focus on the latter condition, unbiasedness.</p>
</section>
<section id="exponential-example" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="exponential-example"><span class="header-section-number">3.2</span> Exponential example</h3>
<p>Consider testing <span class="math inline">\(H_0:\;\theta = 1\)</span> vs <span class="math inline">\(H_1:\;\theta \neq 1\)</span> in the model where <span class="math inline">\(X \sim \text{Exp}(\theta)\)</span>, with cdf <span class="math display">\[F_\theta(t) = \PP_\theta(X \leq t) = 1-e^{-t/\theta}.\]</span> To solve for the equal-tailed test cutoffs we set <span class="math inline">\(c_1^{\text{ET}}=F_1^{-1}(1-\alpha/2) = -\log(1-\alpha/2)\)</span> and <span class="math inline">\(c_2^{\text{ET}}= F_1^{-1}(\alpha/2) = -\log(\alpha/2)\)</span>. Then the power function of the equal-tailed test <span class="math inline">\(\phi^{\text{ET}}\)</span> is</p>
<p><span class="math display">\[
\begin{aligned}
\beta_{\phi^{\text{ET}}}(\theta)
&amp;= \PP_\theta(X &lt; c_1^{\text{ET}}) + \PP_\theta(X &gt; c_2^{\text{ET}})\\
&amp;= 1 - e^{-c_1^{\text{ET}}/\theta} +e^{-c_2^{\text{ET}}/\theta}\\
&amp;= 1 - (1-\alpha/2)^{1/\theta} + (\alpha/2)^{1/\theta}
\end{aligned}
\]</span> This test does indeed have power equal to <span class="math inline">\(\alpha\)</span> at <span class="math inline">\(\theta = 1\)</span>, but its power is also <span class="math inline">\(\alpha\)</span> at <span class="math inline">\(\theta = 1/2\)</span>, and the power is actually below <span class="math inline">\(\alpha\)</span> on <span class="math inline">\((1/2,1)\)</span>. So this is not an unbiased test. If we want an unbiased test, we need to set the <em>derivative</em> of the power equal to <span class="math inline">\(0\)</span> at <span class="math inline">\(\theta = 1\)</span>. We can solve this numerically in terms of the left-lobe rejection probability <span class="math inline">\(\alpha_1\)</span>, taking <span class="math display">\[
\begin{aligned}
c_1(\alpha_1) &amp;=-\log(1-\alpha_1), \quad\text{ and }\\
c_2(\alpha_1) &amp;= -\log(\alpha_2)=-\log(\alpha-\alpha_1).
\end{aligned}
\]</span> If <span class="math inline">\(\alpha = 0.1\)</span> we obtain <span class="math inline">\(\alpha_1 = 0.080\)</span>, <span class="math inline">\(c_1 = 0.083\)</span>, and <span class="math inline">\(c_2 = 3.9\)</span> for the unbiased test, vs <span class="math inline">\(c_1 = 0.051\)</span> and <span class="math inline">\(c_2 = 3.0\)</span> for the equal-tailed test. The unbiased test is not as powerful for <span class="math inline">\(\theta &gt; 1\)</span>, but it is more powerful for <span class="math inline">\(\theta &lt; 1\)</span>, and its power is minimized at <span class="math inline">\(\alpha\)</span> when <span class="math inline">\(\theta = 1\)</span>. We plot both power curves below.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="testing-one-parameter_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="optimal-unbiased-tests" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="optimal-unbiased-tests"><span class="header-section-number">3.3</span> Optimal unbiased tests</h3>
<p>If we are testing a point null against a two-sided alternative, we can take our choice between the equal-tailed and unbiased test, but the unbiasedness criterion is conceptually appealing for more general testing problems because the definition naturally extends to the case where <span class="math inline">\(H_0\)</span> is composite. For example, if we want to test an interval null against a two-sided alternative, it is not clear what it means to set <span class="math inline">\(\PP_{H_0}(T(X) &lt; c_1) = \alpha/2\)</span>, because that probability varies over the null parameter space <span class="math inline">\(\Theta_0\)</span>. By contrast, the unbiased criterion is well-defined for any hypothesis testing problem.</p>
<p>If the power function is differentiable in <span class="math inline">\(\theta\)</span>, and <span class="math inline">\(\theta_0\)</span> is in <span class="math inline">\(\Theta^{\circ}\)</span>, the interior of the parameter space, then any unbiased test <span class="math inline">\(\phi\)</span> must have <span class="math inline">\(\beta_\phi(\theta_0) = \alpha\)</span> and <span class="math inline">\(\dot{\beta}_{\phi}(\theta_0) = 0\)</span>. Otherwise, the power would be strictly less than <span class="math inline">\(\alpha\)</span> at either <span class="math inline">\(\theta_0 +\varepsilon\)</span> or <span class="math inline">\(\theta_0- \varepsilon\)</span>, for sufficiently small <span class="math inline">\(\varepsilon&gt;0\)</span>.</p>
<p>In exponential family models, we can use these facts to obtain a simple characterization of the criterion that the power function has zero derivative at <span class="math inline">\(\theta_0\)</span>, as. Let <span class="math inline">\(X \sim p_\theta(x) = e^{\theta T(x) - A(\theta)}h(x)\)</span>, and differentiate the power function to obtain <span class="math display">\[
\begin{aligned}
\dot{\beta}_{\phi}(\theta_0)
&amp;= \frac{d}{d\theta} \left. \int \phi(x)e^{\theta T(x) - A(\theta)}h(x)\,d\mu(x)\right|_{\theta=\theta_0} \\
&amp;= \int \phi(x)(T(x)-\dot{A}(\theta_0))e^{\theta_0 T(x) - A(\theta_0)}h(x)\,d\mu(x)\\
&amp;= \EE_{\theta_0}\left[\phi(X)(T(X) - \EE_{\theta_0}T(X))\right]\\[5pt]
&amp;= \text{Cov}_{\theta_0}(T(X), \phi(X))\\[5pt]
&amp;= \EE_{\theta_0}\left[(\phi(X)-\alpha)T(X)\right].
\end{aligned}
\]</span> Setting the last expression to 0 and massaging the equation a bit, we obtain <span class="math display">\[
\EE_{\theta_0}T(X) = \frac{\EE_{\theta_0}[\phi(X)T(X)]}{\alpha} = \EE_{\theta_0}[T(X) \mid \phi(X) \text{ rejects } H_0].
\]</span> Thus, the conditional expectation of <span class="math inline">\(T(X)\)</span> under the null, given that it falls in the rejection region, is the same as the marginal expectation. For instance, both the acceptance region and the rejection region for our unbiased test of <span class="math inline">\(H_0:\;\theta=1\)</span> in the exponential model share the same “balance point” at <span class="math inline">\(\EE_{1}X = 1\)</span>. Because the right lobe is farther out from 1, it has only about 1/4 as much probability mass as the right lobe.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="testing-one-parameter_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Recall that when we restricted our attention to unbiased estimators, we were able to find a unique best unbiased estimator. Likewise, we can sometimes find an optimal two-sided test if we restrict our attention to unbiased tests. We say that <span class="math inline">\(\phi^*\)</span> is <em>UMP unbiased</em> (UMPU) if, for any other unbiased level <span class="math inline">\(\alpha\)</span> test <span class="math inline">\(\phi\)</span>, we have <span class="math inline">\(\beta_{\phi^*}(\theta) \geq \beta_{\phi}(\theta)\)</span> for all <span class="math inline">\(\theta \in \Theta_1\)</span>. UMPU tests exist, at least, for one-parameter exponential family models, as we show below.</p>
<p><strong>Theorem (UMP Unbiased tests):</strong> Assume we want to test <span class="math inline">\(H_0:\;|\theta -\theta_0| \leq \delta\)</span> vs <span class="math inline">\(H_1:\;|\theta - \theta_0| &gt; \delta\)</span> in the model <span class="math inline">\(X \sim e^{\theta T(x)-A(\theta)}h(x)\)</span>, for <span class="math inline">\(\delta \geq 0\)</span> and <span class="math inline">\(\theta_0-\delta, \theta+\delta \in \Theta^\circ\)</span>, the interior of the parameter space. Suppose that the test <span class="math inline">\(\phi^*(X)\)</span> rejects for extreme values of <span class="math inline">\(T(X)\)</span>, with the cutoffs <span class="math inline">\(c_1,c_2,\gamma_1,\gamma_2\)</span> chosen so that</p>
<ol type="1">
<li><p><span class="math inline">\(\phi^*\)</span> attains power <span class="math inline">\(\alpha\)</span> at the boundary of the null, i.e.&nbsp;<span class="math inline">\(\beta_{\phi^*}(\theta_0 - \delta) = \beta_{\phi^*}(\theta_0 + \delta) = \alpha\)</span>, and</p></li>
<li><p>if <span class="math inline">\(\delta&gt; 0\)</span>, the power function is flat at <span class="math inline">\(\theta_0\)</span>, i.e.&nbsp;<span class="math inline">\(\dot{\beta}_{\phi^*}(\theta_0) = 0\)</span>.</p></li>
</ol>
<p>Then <span class="math inline">\(\phi^*\)</span> is UMPU.</p>
<p><strong>Proof:</strong> Assume without loss of generality that <span class="math inline">\(\theta_0 = 0\)</span>, and first consider the case <span class="math inline">\(\delta = 0\)</span>. Our proof will proceed much as it did for the Neyman-Pearson lemma. For <span class="math inline">\(\theta \neq 0\)</span>, we want to solve the problem <span class="math display">\[
\begin{aligned}
\maxz_\phi &amp;\int \phi(x)p_{\theta}(x)\,d\mu(x)\\
\text{ subject to } &amp;\int \phi(x)p_0(x)\,d\mu(x) = \alpha, \quad\text{ and }\\
&amp;\int \phi(x)(T(x)-\nu_0)p_0(x)\,d\mu(x) = 0,
\end{aligned}
\]</span> where <span class="math inline">\(\nu_0 = \EE_0 T(X)\)</span>. Note that we have an equality constraint for the Type I error, because any unbiased test must have power exactly equal to <span class="math inline">\(\alpha\)</span> at <span class="math inline">\(\theta_0\)</span>. The Lagrangian is <span class="math display">\[
\begin{aligned}
&amp;\int \phi p_{\theta}\,d\mu - \lambda_1\int \phi p_0\,d\mu - \lambda_2\int \phi (T-\nu_0)p_0 \,d\mu \\
&amp;\quad = \int \phi\left(p_\theta -\lambda_1 p_0 - \lambda_2(T-\nu_0)p_0\right)\,d\mu \\
&amp;\quad = \int \phi\left(\frac{p_\theta}{p_0} - \lambda_1 - \lambda_2(T-\nu_0)\right)\,dP_0.
\end{aligned}
\]</span> Since <span class="math inline">\(\frac{p_\theta}{p_0}(x) = e^{\theta T(x) - A(\theta)+A(0)}\)</span>, the test that maximizes this Lagrangian has <span class="math display">\[
\phi^*(x) = \begin{cases} 1 &amp;\quad \text{ if } e^{\theta T(x)} &gt; a_0 + a_1 T(x)\\
0 &amp;\quad \text{ if } e^{\theta T(x)} &lt; a_0 + a_1 T(x)\\
\text{anything} &amp;\quad \text{ if } e^{\theta T(x)} = a_0 + a_1 T(x)
\end{cases}
\]</span> for <span class="math inline">\(a_0 = (\lambda_1 - \lambda_2\nu_0)e^{A(0)-A(\theta)}\)</span> and <span class="math inline">\(a_1 = \lambda_2 e^{A(0)-A(\theta)}\)</span>.</p>
<p>For any <span class="math inline">\(c_1,c_2\)</span> we can find <span class="math inline">\(a_1 &gt; 0\)</span> and <span class="math inline">\(a_0\in \RR\)</span> for which <span class="math inline">\(e^{\theta t} = a_0 + a_1 t\)</span> at <span class="math inline">\(t = c_1,c_2\)</span>, in which case <span class="math inline">\(e^{t\theta} &gt; a_0 + a_1 t\)</span> for <span class="math inline">\(t &lt; c_1\)</span> and <span class="math inline">\(t &gt; c_2\)</span> and <span class="math inline">\(e^{t\theta} &lt; a_0 + a_1 t\)</span> otherwise; then we can solve for <span class="math inline">\(\lambda_1,\lambda_2 \in \RR\)</span> for which our <span class="math inline">\(\phi^*\)</span> maximizes the Lagrangian.</p>
<p>Now, for any other test <span class="math inline">\(\phi\)</span> that satisfies the unbiasedness constraints we can write <span class="math display">\[
\begin{aligned}
\beta_{\phi}(\theta)  
&amp;= \beta_{\phi}(\theta) - \lambda_1\left(\beta_{\phi}(0) - \alpha\right) -\lambda_2 \dot\beta_{\phi}(0)\\
&amp;\leq \beta_{\phi^*}(\theta) - \lambda_1\left(\beta_{\phi^*}(0) - \alpha\right) -\lambda_2 \dot\beta_{\phi^*}(0)\\
&amp;= \beta_{\phi^*}(\theta).
\end{aligned}
\]</span> Since <span class="math inline">\(\theta\)</span> was arbitrary, we have the result.</p>
<p>The proof for <span class="math inline">\(\delta &gt; 0\)</span> is similar, with the constraints <span class="math inline">\(\beta_{\phi}(0) = \alpha\)</span> and <span class="math inline">\(\dot{\beta}_{\phi}(0) = 0\)</span> replaced by <span class="math inline">\(\beta_{\phi}(-\delta) = \beta_{\phi}(\delta) =\alpha\)</span>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/stat210a\.berkeley\.edu\/fall-2025\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>